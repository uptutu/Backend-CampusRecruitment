# 数据结构

## 链表

https://www.jianshu.com/p/7924cf19f128

---



## 树

### 二叉树

**二叉树**：二叉树是有限个结点的集合，这个集合或者是空集，或者是由一个根结点和两株互不相交的二叉树组成，其中一株叫根的做左子树，另一棵叫做根的右子树。

**二叉树的性质**：

- 性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1）
- 性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1）
- 性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：`n0 = n2 + 1`

**满二叉树**：深度为k且有2^k －1个结点的二叉树称为满二叉树

**完全二叉树**：深度为 k 的，有n个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应，称之为完全二叉树。（除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点）

- 性质4：具有 n 个结点的完全二叉树的深度为 log2n + 1

**注意**：

- 仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果

### 堆

如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为最大堆。

同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为最小堆。

**最大堆的根结点中的元素在整个堆中是最大的；**

**最小堆的根结点中的元素在整个堆中是最小的。**

### 哈弗曼树

- 定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。

- 构造：

  假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：

  1. 将w1、w2、…，wn看成是有 n 棵树的森林(每棵树仅有一个结点)；
  2. 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
  3. 从森林中删除选取的两棵树，并将新树加入森林；
  4. 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

### 二叉排序树

二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。

二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
3. 左、右子树也分别为二叉排序树；
4. 没有键值相等的节点

二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）

### 平衡二叉树

平衡二叉树（balanced  binary  tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树：

1. 它的左子树和右子树都是平衡二叉树，
2. 左子树和右子树的深度之差的绝对值不超过1。

平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。

### B-树

**B-树**：B-树是一种非二叉的查找树， 除了要满足查找树的特性，还要满足以下结构特性：

一棵 m 阶的B-树：

1. 树的根或者是一片叶子(一个节点的树),或者其儿子数在 2 和 m 之间。
2. 除根外，所有的非叶子结点的孩子数在 m/2 和 m 之间。
3. 所有的叶子结点都在相同的深度。

B-树的平均深度为logm/2(N)。执行查找的平均时间为O(logm)；

### Trie 树

Trie 树，又称前缀树，字典树，  是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。

Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。

### 红黑树

红黑树，Red-Black Tree 「RBT」是一个自平衡(不是绝对的平衡)的二叉查找树(BST)，树上的每个节点都遵循下面的规则:

1. 每个节点都有红色或黑色
2. 树的根始终是黑色的 (黑土地孕育黑树根， )
3. 没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，**并没有说不能出现连续的黑色节点**）
4. 从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点

红黑树有两大操作:

1. recolor (重新标记黑色或红色)
2. rotation (旋转，这是树达到平衡的关键)

我们会先尝试 recolor，如果 recolor 不能达到红黑树的 4 点要求，然后我们尝试 rotation，其实红黑树的关键玩法就是弄清楚 recolor 和 rotation 的规则。



**参考** ：

 https://hit-alibaba.github.io/interview/basic/algo/Tree.html

https://zhuanlan.zhihu.com/p/79980618、

---



## 哈希表

哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。

### 冲突解决

现实中的哈希函数不是完美的，当两个不同的输入值对应一个输出值时，就会产生“碰撞”，这个时候便需要解决冲突。

常见的冲突解决方法有 **开放定址法**，**再哈希法**，**链地址法**，**建立公共溢出区 **等。实际的哈希表实现中，使用最多的是链地址法。

### 参考：

http://data.biancheng.net/view/63.html

---

# 算法

## 排序

###### 常见排序算法

常见的稳定排序算法有：

- 冒泡排序（Bubble Sort） — O(n²)
- 插入排序（Insertion Sort）— O(n²)
- 桶排序（Bucket Sort）— O(n); 需要 O(k) 额外空间
- 计数排序 (Counting Sort) — O(n+k); 需要 O(n+k) 额外空间
- **合并排序**（Merge Sort）— O(nlogn); 需要 O(n) 额外空间
- 二叉排序树排序 （Binary tree sort） — O(n log n) 期望时间; O(n²)最坏时间; 需要 O(n) 额外空间
- 基数排序（Radix sort）— O(n·k); 需要 O(n) 额外空间

常见的不稳定排序算法有：

- 选择排序（Selection Sort）— O(n²)
- 希尔排序（Shell Sort）— O(nlogn)
- 堆排序（Heapsort）— O(nlogn)
- **快速排序**（Quicksort）— O(nlogn) 期望时间, O(n²) 最坏情况; 对于大的、乱数串行一般相信是最快的已知排序



###### 冒泡排序

![img](https://n.sinaimg.cn/sinakd2020928s/77/w1080h597/20200928/c907-izwfpys3056866.png)

![img](https://n.sinaimg.cn/sinakd2020928s/600/w678h722/20200928/e9a5-izwfpys3057091.png)

以顺序为例，从第一个元素开始一个一个的比较相邻的元素，如果第一个比第二个大即a[1]>a[2]，就彼此交换。

###### 选择排序

![img](https://n.sinaimg.cn/sinakd2020928s/726/w1080h446/20200928/006c-izwfpys3057224.png)

![img](https://n.sinaimg.cn/sinakd2020928s/600/w678h722/20200928/def5-izwfpys3057230.png)

选择排序是一种简单直观的排序算法，它从待排序的数据元素中选出最小或最大的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小或最大元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。

###### 插入排序

![img](https://n.sinaimg.cn/sinakd2020928s/753/w1080h473/20200928/b717-izwfpys3057441.png)

![img](https://n.sinaimg.cn/sinakd2020928s/700/w678h822/20200928/00f2-izwfpys3057695.png)

首先将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。每一步将一个待排序的元素，按其排序码的大小，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止。可以选择不同的方法在已经排好序数据表中寻找插入位置。根据查找方法不同，有多种插入排序方法，下面要介绍的是直接插入排序。 每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。第一趟比较前两个数，然后把第二个数按大小插入到有序表中；第二趟把第三个数据与前两个数从后向前扫描，把第三个数按大小插入到有序表中；依次进行下去，进行了(n-1)趟扫描以后就完成了整个排序过程。

###### 希尔排序

![img](https://n.sinaimg.cn/sinakd2020928s/47/w1080h567/20200928/0cbe-izwfpys3057882.png)

![img](https://upload-images.jianshu.io/upload_images/6095354-ff984d80dbc0455f.png?imageMogr2/auto-orient/strip|imageView2/2)

希尔排序是将待排序的数组元素 按下标的一定增量分组 ，分成多个子序列，然后对各个子序列进行直接插入排序算法排序；然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序，排序结束。

（**注：**为方便记忆算法，我习惯将其记作**“三层for循环+if”** ------** for（for（for（if）））**）

参考

https://www.jianshu.com/p/d730ae586cf3



###### 堆排序

![img](https://n.sinaimg.cn/sinakd2020928s/3/w1080h523/20200928/848f-izwfpys3058061.png)



什么是堆？由于堆排序比较特殊，我们先了解一下堆是什么。堆是一种非线性的数据结构，其实就是利用完全二叉树的结构来维护的一维数组，利用这种结构可以快速访问到需要的值，堆可以分为大顶堆和小顶堆。大顶堆：每个结点的值都大于或等于其左右孩子结点的值小顶堆：每个结点的值都小于或等于其左右孩子结点的值。

首先把待排序的元素按照大小在二叉树位置上排列，且要满足堆的特性，如果根节点存放的是最大的数，则叫做大根堆，反之就叫做小根堆了。根据这个特性就可以把根节点拿出来，然后再堆化下，即用父节点和他的孩子节点进行比较，取最大的孩子节点和其进行交换，再把根节点拿出来，一直循环到最后一个节点，就排序好了。

###### 归并排序

**归并排序**是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用，其核心思想是将两个有序的数列合并成一个大的有序的序列。

![img](https://n.sinaimg.cn/sinakd2020928s/12/w1080h532/20200928/ec93-izwfpys3058287.png)

首先将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序。过程如下： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列设定两个指针，最初位置分别为两个已经排序序列的起始位置比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤c直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾

![img](https://n.sinaimg.cn/sinakd2020928s/300/w678h422/20200928/f449-izwfpys3058530.png)

###### 快速排序

快速排序在1960年提出，是考察次数最多的排序，无论是在大学专业课的期末考试，还是在公司的面试测试题目中，快速排序都极大的被使用，在实际中快速排序也极大的被使用。

![img](https://n.sinaimg.cn/sinakd2020928s/39/w1080h559/20200928/33e5-izwfpys3058714.png)

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 在数组中选择一个基准点分别从数组的两端扫描数组，设两个指示标志从后半部分开始，如果发现有元素比该基准点的值小，就交换位置然后从前半部分开始扫描，发现有元素大于基准点的值，继续交换位置如此往复循环，然后把基准点的值放到high这个位置,排序完成 以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。

![img](https://n.sinaimg.cn/sinakd2020928s/390/w678h512/20200928/faa4-izwfpys3058716.png)

其实每一次选取标杆遍历后都相当于把这个标杆放在了整个数组中属于它排好序的位置上。

参考

https://www.sohu.com/a/246785807_684445

###### 桶排序

桶排序也称箱排序，原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。

![img](https://n.sinaimg.cn/sinakd2020928s/18/w1080h538/20200928/0504-izwfpys3059169.png)

![img](https://n.sinaimg.cn/sinakd2020928s/22/w631h191/20200928/503a-izwfpys3059281.png)

根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数；遍历待排序集合，将每一个元素移动到对应的桶中；对每一个桶中元素进行排序，并移动到已排序集合中。

###### 基数排序

基数排序是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，在某些时候，基数排序法的效率高于其它的稳定性排序法。

![img](https://n.sinaimg.cn/sinakd2020928s/791/w1080h511/20200928/6239-izwfpys3059358.png)

![img](https://n.sinaimg.cn/sinakd2020928s/742/w351h391/20200928/d710-izwfpys3059425.png)

任何一个阿拉伯数，它的各个位数上的基数都是以0~9来表示的。所以我们不妨把0~9视为10个桶。 我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。分类后，我们在从各个桶中，将这些数按照从编号0到编号9的顺序依次将所有数取出来。得到的序列就是个位数上呈递增趋势的序列。按照上图个位数排序：{50, 30, 0, 100, 11, 2, 123, 543, 187, 49}。接下来对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。



###### 参考

https://t.cj.sina.com.cn/articles/view/6080368657/16a6b101101900svla?from=tech&wm=3049_0032



---



##### 搜索



---



##### 字符串



---



##### 动态规划



---



