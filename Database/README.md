# 数据库

---

## 索引能干啥？

大大提高系统性能

### 优点

1. 通过创建 unique 唯一索引能 **保证** 数据库表中的每一行数据的唯一性
2. 大大加快数据的 **检索** 速度，这也是创建索引的最主要原因
3. 在实现数据的参考完整性方面可以 **加速表与表之间的连接** 
4. 在使用分组和排序子句进行数据查询时也可以显著减少查询中分组和排序的时间

### 缺点

1. **索引的创建和维护 **的时间随着数量增加而增加
2. 索引会 **占据数据空间**，还要占一定的物理空间



## 事务

### 什么是事务

事务是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消。可以通俗理解为：就是把多件事情当做一件事情来处理，好比大家同在一条船上，要活一起活，要完一起完 。

#### 事务的四个特性（ACID）

- 原子性 [atomicity]
-  一致性 [consistency]
-  隔离性 [isolation]
-  持久性 [durability]

### 概念解释

| 名称       | 解释                                                         |
| :--------- | :----------------------------------------------------------- |
| 原子性     | 是操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。 |
| 一致性     | 事物的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。 |
| 隔离性     | 隔离性是多个用户并发访问数据库时，比如操作同一张表时，数据库为每个用户开启的事务，不能被其他事务的操作所干扰，多个并发事物之间要相互隔离。对于任意两个并发的事务 t1 和 t2，在事物 t1 看来，t2 要么在 t1 开始之前就已经结束，要么在 t1  结束之后才开始，这样每个事物都感觉不到其他事务在并发地执行。 |
| 持久性     | 当事务正确完成后，他对于数据的改变时持久的。                 |
| 读未提交   | 最低级别，任何情况都无法保证。读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。 |
| 读已提交   | 可避免脏读的发生。读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 |
| 可重复读   | 可避免脏读、不可重复读的发生。重复读，就是开始读取数据时 [事务开启]，不在允许修改操作。 |
| 串行化     | 可避免脏读、不可重复读、幻读的发生。是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可避免脏读、不可重复读、幻读。但是这样事务隔离级别效率低下，比较耗数据库性能，一般不使用。 |
| 脏读       | 一个事务处理过程中读取了另一个未提交的事物中的数据。         |
| 幻读、虚读 | 一个事务执行两次查询，第二次结果集包含第一次中没有或某些行已经被删除的数据，造成两次结果不一致，只是另一个事务在这两次查询中间插入或删除了数据造成的。 |
| 不可重复读 | 一个事务两次读取同一行的数据，结果得到不同状态的结果，中间正好另一个事务更新了该数据，两次结果相异，不可被信任。 |

### 数据事务的隔离级别

事务的隔离级别有 4 种，由低到高分别为 

- Read uncommitted	最低级别，任何情况都无法保证
- Read committed        可避免脏读的发生
- Repeatable read        可避免脏读、不可重复读的发生
- Serializable                可避免脏读、不可重复读、幻读的发生

而且，在事务的并发操作中可能出现脏读、不可重复读、幻读。

Mysql 的 **默认隔离级别是 Repeatable read** 

#### 不可重复读和脏读的区别

不可重复读和脏读的区别：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。　

#### 幻读和不可重复读都区别

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

#### 资料

https://www.cnblogs.com/Kevin-ZhangCG/p/9038371.html

https://learnku.com/articles/51110