# 数据库

---

# MySQL

## 索引能干啥？

大大提高系统性能

### 优点

1. 通过创建 unique 唯一索引能 **保证** 数据库表中的每一行数据的唯一性
2. 大大加快数据的 **检索** 速度，这也是创建索引的最主要原因
3. 在实现数据的参考完整性方面可以 **加速表与表之间的连接** 
4. 在使用分组和排序子句进行数据查询时也可以显著减少查询中分组和排序的时间

### 缺点

1. **索引的创建和维护 **的时间随着数量增加而增加
2. 索引会 **占据数据空间**，还要占一定的物理空间



## 事务

### 什么是事务

事务是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消。可以通俗理解为：就是把多件事情当做一件事情来处理，好比大家同在一条船上，要活一起活，要完一起完 。

#### 事务的四个特性（ACID）

- 原子性 [atomicity]
-  一致性 [consistency]
-  隔离性 [isolation]
-  持久性 [durability]

### 概念解释

| 名称       | 解释                                                         |
| :--------- | :----------------------------------------------------------- |
| 原子性     | 是操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。 |
| 一致性     | 事物的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。 |
| 隔离性     | 隔离性是多个用户并发访问数据库时，比如操作同一张表时，数据库为每个用户开启的事务，不能被其他事务的操作所干扰，多个并发事物之间要相互隔离。对于任意两个并发的事务 t1 和 t2，在事物 t1 看来，t2 要么在 t1 开始之前就已经结束，要么在 t1  结束之后才开始，这样每个事物都感觉不到其他事务在并发地执行。 |
| 持久性     | 当事务正确完成后，他对于数据的改变时持久的。                 |
| 读未提交   | 最低级别，任何情况都无法保证。读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。 |
| 读已提交   | 可避免脏读的发生。读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 |
| 可重复读   | 可避免脏读、不可重复读的发生。重复读，就是开始读取数据时 [事务开启]，不在允许修改操作。 |
| 串行化     | 可避免脏读、不可重复读、幻读的发生。是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可避免脏读、不可重复读、幻读。但是这样事务隔离级别效率低下，比较耗数据库性能，一般不使用。 |
| 脏读       | 一个事务处理过程中读取了另一个未提交的事物中的数据。         |
| 幻读、虚读 | 一个事务执行两次查询，第二次结果集包含第一次中没有或某些行已经被删除的数据，造成两次结果不一致，只是另一个事务在这两次查询中间插入或删除了数据造成的。 |
| 不可重复读 | 一个事务两次读取同一行的数据，结果得到不同状态的结果，中间正好另一个事务更新了该数据，两次结果相异，不可被信任。 |

### 数据事务的隔离级别

事务的隔离级别有 4 种，由低到高分别为 

- Read uncommitted	最低级别，任何情况都无法保证
- Read committed        可避免脏读的发生
- Repeatable read        可避免脏读、不可重复读的发生
- Serializable                可避免脏读、不可重复读、幻读的发生

而且，在事务的并发操作中可能出现脏读、不可重复读、幻读。

Mysql 的 **默认隔离级别是 Repeatable read** 

#### 不可重复读和脏读的区别

不可重复读和脏读的区别：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。　

#### 幻读和不可重复读都区别

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

### 隔离级别的实现原理

> 使用MySQL的默认隔离级别（可重复读）来进行说明。
>
> 每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。即通过回滚（rollback操作），可以回到前一个状态的值。
>
> 假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

![彻底搞懂 MySQL 事务的隔离级别](README.assets/mfZfSEBBSn.png!large)

> 当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C  里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view  A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。
>
> 同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。
>
> 提问：回滚操作日志（undo log）什么时候删除？
>
> MySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。
>
> 提问：什么时候不需要了？
>
> 当系统里么有比这个回滚日志更早的read-view的时候。

#### 资料

https://www.cnblogs.com/Kevin-ZhangCG/p/9038371.html

https://learnku.com/articles/51110

https://developer.aliyun.com/article/743691



## 存储引擎

### InnoDB

`InnoDB`是一个将表中的数据存储到磁盘上的存储引擎

`InnoDB`采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 ***16*** KB。

`MySQL`中磁盘和内存交互的基本单位是`页`，也就是说`MySQL`是以`页`为基本单位来管理存储空间的，我们的记录都会被分配到某个`页`中存储。而一个页的大小一般是`16KB`，也就是`16384`字节.

#### InnoDB 行格式

我们可以在创建或修改表的语句中指定`行格式`：

```SQL
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为`行格式`或者`记录格式`。

##### Compact

![img](/Users/alexkung/Code/Backend-CampusRecruitment/我的后端校招.assets/169710e8fafc21aa.png)

###### 记录的额外信息

这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类

- 变长字段长度列表
- NULL值列表
- 记录头信息

*变长字段长度列表*

`MySQL` 支持一些变长的数据类型，比如`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型，各种`BLOB`类型，这些数据类型的列称为`变长字段`，变长字段中存储多少字节的数据是不固定的，所以在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把`MySQL`服务器搞懵，所以这些变长字段占用的存储空间分为两部分：

1. 真正的数据内容
2. 占用的字节数

在`Compact`行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！

*NULL 值列表*

`Compact`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中

*记录头信息*

它是由固定的`5`个字节组成。`5`个字节也就是`40`个二进制位，不同的位代表不同的意思，如图：

![img](/Users/alexkung/Code/Backend-CampusRecruitment/我的后端校招.assets/169710e97718ef01.png)

###### 记录的真实数据

`MySQL`会为每个记录默认的添加一些列（也称为`隐藏列`），具体的列如下：

|       列名       | 是否必须 | 占用空间 |          描述          |
| :--------------: | :------: | :------: | :--------------------: |
|     `row_id`     |    否    | `6`字节  | 行ID，唯一标识一条记录 |
| `transaction_id` |    是    | `6`字节  |         事务ID         |
|  `roll_pointer`  |    是    | `7`字节  |        回滚指针        |

```
小贴士： 实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，我们为了美观才写成了row_id、transaction_id 和 roll_pointer。
```

`InnoDB`表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为`row_id`的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 ***transaction_id*** 和 ***roll_pointer*** 这两个列，但是 ***row_id*** 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心，`InnoDB`存储引擎会自己帮我们生成的。

变长字符集的`CHAR(M)`类型的列要求至少占用`M`个字节，而`VARCHAR(M)`却没有这个要求。比方说对于使用`utf8`字符集的`CHAR(10)`的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用`10`个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。（这里你感受到设计`Compact`行格式的大叔既想节省存储空间，又不想更新`CHAR(M)`类型的列产生碎片时的纠结心情了吧。）

##### Redundant

是`MySQL5.0`之前用的一种行格式

![img](/Users/alexkung/Code/Backend-CampusRecruitment/我的后端校招.assets/169710e99a69ba3d.png)

`字段长度偏移列表`实质上是存储每个列中的值占用的空间在`记录的真实数据`处结束的位置.

`MySQL`中磁盘和内存交互的基本单位是`页`，也就是说`MySQL`是以`页`为基本单位来管理存储空间的，我们的记录都会被分配到某个`页`中存储。而一个页的大小一般是`16KB`，也就是`16384`字节

##### Dynamic

MySQL 5.7 默认行格式

和`Compact`行格式挺像，只不过在处理`行溢出`数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前`768`个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：

![img](/Users/alexkung/Code/Backend-CampusRecruitment/我的后端校招.assets/169710e9b2c2b71e.png)



##### Compressed

`Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。

#### 行溢出的临界点

那发生`行溢出`的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生`行溢出`？

`MySQL`中规定一个页中至少存放两行记录,

`MySQL`中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。以上边的`varchar_size_demo`表为例，它只有一个列`c`，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会`行溢出`的现象呢？这得分析一下页中的空间都是如何利用的。

- 每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要`132`个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。

- 每个记录需要的额外信息是`27`字节。

  这27个字节包括下边这些部分：

  - 2个字节用于存储真实数据的长度
  - 1个字节用于存储列是否是NULL值
  - 5个字节大小的头信息
  - 6个字节的`row_id`列
  - 6个字节的`transaction_id`列
  - 7个字节的`roll_pointer`列

假设一个列中存储的数据字节数为n，设计`MySQL`的大叔规定如果该列不发生溢出的现象，就需要满足下边这个式子：

```
132 + 2×(27 + n) < 16384
```

求解这个式子得出的解是：`n < 8099`。也就是说如果一个列中存储的数据小于`8099`个字节，那么该列就不会成为`溢出列`，否则该列就需要成为`溢出列`。不过这个`8099`个字节的结论只是针对只有一个列的`varchar_size_demo`表来说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：你不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为`溢出列`。

#### InnoDB数据页结构

前边我们简单提了一下`页`的概念，它是`InnoDB`管理存储空间的基本单位，一个页的大小一般是`16KB`。`InnoDB`为了不同的目的而设计了许多种不同类型的`页`，比如存放表空间头部信息的页，存放`Insert Buffer`信息的页，存放`INODE`信息的页，存放`undo`日志信息的页等等等等。

![https://user-gold-cdn.xitu.io/2019/12/17/16f13ee1e2dfac7c?imageslim](README.assets/16f13ee1e2dfac7c.png)

| 名称                 | 中文名             | 占用空间大小 | 简单描述                 |
| -------------------- | ------------------ | ------------ | ------------------------ |
| `File Header`        | 文件头部           | `38`字节     | 页的一些通用信息         |
| `Page Header`        | 页面头部           | `56`字节     | 数据页专有的一些信息     |
| `Infimum + Supremum` | 最小记录和最大记录 | `26`字节     | 两个虚拟的行记录         |
| `User Records`       | 用户记录           | 不确定       | 实际存储的行记录内容     |
| `Free Space`         | 空闲空间           | 不确定       | 页中尚未使用的空间       |
| `Page Directory`     | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
| `File Trailer`       | 文件尾部           | `8`字节      | 校验页是否完整           |



### 再谈索引

索引目录本体实质为一个基础单位——页

#### 聚簇索引

聚簇索引不是人为创建的，默认就有。

根据数据记录所在的页而不断提炼的 B+ 树，叶子节点是数据记录所在的页的

#### 二级索引

本质也是一颗 B+ 树，更具所选数据栏排序出来的另一颗树，只是叶子节点上不是记录数据其实实体，而是记录着索引栏和主键的页记录，最后在有一个回表操作——聚簇索引目录根据主键首选记录实体。

#### 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让`B+`树按照`c2`和`c3`列的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照`c2`列进行排序。
- 在记录的`c2`列相同的情况下，采用`c3`列进行排序

千万要注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。

#### MyISAM中的索引方案简单介绍

我们知道`InnoDB`中索引即数据，也就是聚簇索引的那棵`B+`树的叶子节点中已经把所有完整的用户记录都包含了，而`MyISAM`的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：

- 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为`数据文件`。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。

由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。

使用`MyISAM`存储引擎的表会把索引信息另外存储到一个称为`索引文件`的另一个文件中。`MyISAM`会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是`主键值 + 行号`的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！

这一点和`InnoDB`是完全不相同的，在`InnoDB`存储引擎中，我们只需要根据主键值对`聚簇索引`进行一次查找就能找到对应的记录，而在`MyISAM`中却需要进行一次`回表`操作，意味着`MyISAM`中建立的索引相当于全部都是`二级索引`！

#### 索引的代价

- 空间上的代价

  这个是显而易见的，每建立一个索引都要为它建立一棵`B+`树，每一棵`B+`树的每一个节点都是一个数据页，一个页默认会占用`16KB`的存储空间，一棵很大的`B+`树由许多数据页组成，那可是很大的一片存储空间呢。

- 时间上的代价

  每次对表中的数据进行增、删、改操作时，都需要去修改各个`B+`树索引。而且我们讲过，`B+`树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的`B+`树都要进行相关的维护操作，这还能不给性能拖后腿么？

#### 总结

- 每个索引都对应一棵`B+`树，`B+`树分为好多层，最下边一层是叶子节点，其余的是内节点。所有`用户记录`都存储在`B+`树的叶子节点，所有`目录项记录`都存储在内节点。
- `InnoDB`存储引擎会自动为主键（如果没有它会自动帮我们添加）建立`聚簇索引`，聚簇索引的叶子节点包含完整的用户记录。
- 我们可以为自己感兴趣的列建立`二级索引`，`二级索引`的叶子节点包含的用户记录由`索引列 + 主键`组成，所以如果想通过`二级索引`来查找完整的用户记录的话，需要通过`回表`操作，也就是在通过`二级索引`找到主键值之后再到`聚簇索引`中查找完整的用户记录。
- `B+`树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是`联合索引`的话，则页面和记录先按照`联合索引`前边的列排序，如果该列值相同，再按照`联合索引`后边的列排序。
- 通过索引查找记录是从`B+`树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了`Page Directory`（页目录），所以在这些页面中的查找非常快。

