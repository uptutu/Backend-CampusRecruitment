# 数据库

---

# MySQL

## 索引能干啥？

大大提高系统性能

### 优点

1. 通过创建 unique 唯一索引能 **保证** 数据库表中的每一行数据的唯一性
2. 大大加快数据的 **检索** 速度，这也是创建索引的最主要原因
3. 在实现数据的参考完整性方面可以 **加速表与表之间的连接** 
4. 在使用分组和排序子句进行数据查询时也可以显著减少查询中分组和排序的时间

### 缺点

1. **索引的创建和维护 **的时间随着数量增加而增加
2. 索引会 **占据数据空间**，还要占一定的物理空间



## 事务

### 什么是事务

事务是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消。可以通俗理解为：就是把多件事情当做一件事情来处理，好比大家同在一条船上，要活一起活，要完一起完 。

#### 事务的四个特性（ACID）

- 原子性 [atomicity]
-  一致性 [consistency]
-  隔离性 [isolation]
-  持久性 [durability]

### 概念解释

| 名称       | 解释                                                         |
| :--------- | :----------------------------------------------------------- |
| 原子性     | 是操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。 |
| 一致性     | 事物的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。 |
| 隔离性     | 隔离性是多个用户并发访问数据库时，比如操作同一张表时，数据库为每个用户开启的事务，不能被其他事务的操作所干扰，多个并发事物之间要相互隔离。对于任意两个并发的事务 t1 和 t2，在事物 t1 看来，t2 要么在 t1 开始之前就已经结束，要么在 t1  结束之后才开始，这样每个事物都感觉不到其他事务在并发地执行。 |
| 持久性     | 当事务正确完成后，他对于数据的改变时持久的。                 |
| 读未提交   | 最低级别，任何情况都无法保证。读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。 |
| 读已提交   | 可避免脏读的发生。读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 |
| 可重复读   | 可避免脏读、不可重复读的发生。重复读，就是开始读取数据时 [事务开启]，不在允许修改操作。 |
| 串行化     | 可避免脏读、不可重复读、幻读的发生。是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可避免脏读、不可重复读、幻读。但是这样事务隔离级别效率低下，比较耗数据库性能，一般不使用。 |
| 脏读       | 一个事务处理过程中读取了另一个未提交的事物中的数据。         |
| 幻读、虚读 | 一个事务执行两次查询，第二次结果集包含第一次中没有或某些行已经被删除的数据，造成两次结果不一致，只是另一个事务在这两次查询中间插入或删除了数据造成的。 |
| 不可重复读 | 一个事务两次读取同一行的数据，结果得到不同状态的结果，中间正好另一个事务更新了该数据，两次结果相异，不可被信任。 |

### 数据事务的隔离级别

事务的隔离级别有 4 种，由低到高分别为 

- Read uncommitted	最低级别，任何情况都无法保证
- Read committed        可避免脏读的发生
- Repeatable read        可避免脏读、不可重复读的发生
- Serializable                可避免脏读、不可重复读、幻读的发生

而且，在事务的并发操作中可能出现脏读、不可重复读、幻读。

Mysql 的 **默认隔离级别是 Repeatable read** 

#### 不可重复读和脏读的区别

不可重复读和脏读的区别：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。　

#### 幻读和不可重复读都区别

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

#### 资料

https://www.cnblogs.com/Kevin-ZhangCG/p/9038371.html

https://learnku.com/articles/51110



## 存储引擎

### InnoDB

`InnoDB`是一个将表中的数据存储到磁盘上的存储引擎

`InnoDB`采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 ***16*** KB。

`MySQL`中磁盘和内存交互的基本单位是`页`，也就是说`MySQL`是以`页`为基本单位来管理存储空间的，我们的记录都会被分配到某个`页`中存储。而一个页的大小一般是`16KB`，也就是`16384`字节.

#### InnoDB 行格式

我们可以在创建或修改表的语句中指定`行格式`：

```SQL
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为`行格式`或者`记录格式`。

##### Compact

![img](/Users/alexkung/Code/Backend-CampusRecruitment/我的后端校招.assets/169710e8fafc21aa.png)

###### 记录的额外信息

这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类

- 变长字段长度列表
- NULL值列表
- 记录头信息

*变长字段长度列表*

`MySQL` 支持一些变长的数据类型，比如`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型，各种`BLOB`类型，这些数据类型的列称为`变长字段`，变长字段中存储多少字节的数据是不固定的，所以在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把`MySQL`服务器搞懵，所以这些变长字段占用的存储空间分为两部分：

1. 真正的数据内容
2. 占用的字节数

在`Compact`行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！

*NULL 值列表*

`Compact`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中

*记录头信息*

它是由固定的`5`个字节组成。`5`个字节也就是`40`个二进制位，不同的位代表不同的意思，如图：

![img](/Users/alexkung/Code/Backend-CampusRecruitment/我的后端校招.assets/169710e97718ef01.png)

###### 记录的真实数据

`MySQL`会为每个记录默认的添加一些列（也称为`隐藏列`），具体的列如下：

|       列名       | 是否必须 | 占用空间 |          描述          |
| :--------------: | :------: | :------: | :--------------------: |
|     `row_id`     |    否    | `6`字节  | 行ID，唯一标识一条记录 |
| `transaction_id` |    是    | `6`字节  |         事务ID         |
|  `roll_pointer`  |    是    | `7`字节  |        回滚指针        |

```
小贴士： 实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，我们为了美观才写成了row_id、transaction_id和roll_pointer。
```

`InnoDB`表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为`row_id`的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 ***transaction_id*** 和 ***roll_pointer*** 这两个列，但是 ***row_id*** 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心，`InnoDB`存储引擎会自己帮我们生成的。

变长字符集的`CHAR(M)`类型的列要求至少占用`M`个字节，而`VARCHAR(M)`却没有这个要求。比方说对于使用`utf8`字符集的`CHAR(10)`的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用`10`个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。（这里你感受到设计`Compact`行格式的大叔既想节省存储空间，又不想更新`CHAR(M)`类型的列产生碎片时的纠结心情了吧。）

##### Redundant

是`MySQL5.0`之前用的一种行格式

![img](/Users/alexkung/Code/Backend-CampusRecruitment/我的后端校招.assets/169710e99a69ba3d.png)

`字段长度偏移列表`实质上是存储每个列中的值占用的空间在`记录的真实数据`处结束的位置.

`MySQL`中磁盘和内存交互的基本单位是`页`，也就是说`MySQL`是以`页`为基本单位来管理存储空间的，我们的记录都会被分配到某个`页`中存储。而一个页的大小一般是`16KB`，也就是`16384`字节

##### Dynamic

MySQL 5.7 默认行格式

和`Compact`行格式挺像，只不过在处理`行溢出`数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前`768`个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：

![img](/Users/alexkung/Code/Backend-CampusRecruitment/我的后端校招.assets/169710e9b2c2b71e.png)



##### Compressed

`Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。

#### 行溢出的临界点

那发生`行溢出`的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生`行溢出`？

`MySQL`中规定一个页中至少存放两行记录,

`MySQL`中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。以上边的`varchar_size_demo`表为例，它只有一个列`c`，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会`行溢出`的现象呢？这得分析一下页中的空间都是如何利用的。

- 每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要`132`个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。

- 每个记录需要的额外信息是`27`字节。

  这27个字节包括下边这些部分：

  - 2个字节用于存储真实数据的长度
  - 1个字节用于存储列是否是NULL值
  - 5个字节大小的头信息
  - 6个字节的`row_id`列
  - 6个字节的`transaction_id`列
  - 7个字节的`roll_pointer`列

假设一个列中存储的数据字节数为n，设计`MySQL`的大叔规定如果该列不发生溢出的现象，就需要满足下边这个式子：

```
132 + 2×(27 + n) < 16384
```

求解这个式子得出的解是：`n < 8099`。也就是说如果一个列中存储的数据小于`8099`个字节，那么该列就不会成为`溢出列`，否则该列就需要成为`溢出列`。不过这个`8099`个字节的结论只是针对只有一个列的`varchar_size_demo`表来说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：你不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为`溢出列`。